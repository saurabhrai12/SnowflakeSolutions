name: ğŸ“Š Streamlit App ECS Deployment

on:
  # Manual trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

  # Automatic triggers based on branch and path
  push:
    branches: [main, 'feature/*', 'feat/*']
    paths: 
      - 'streamlit-app/**'
      - '.github/workflows/streamlit-app-deployment.yml'

  # Pull request trigger for dev deployment
  pull_request:
    branches: [main]
    paths:
      - 'streamlit-app/**'
      - '.github/workflows/streamlit-app-deployment.yml'

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: snowflake-streamlit-app
  ECS_CLUSTER: snowflake-analytics-cluster
  ECS_SERVICE: streamlit-cortex-analyst
  CONTAINER_NAME: streamlit-app
  
jobs:
  # Determine deployment environment and parameters
  setup:
    name: ğŸ—ï¸ Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.setup.outputs.environment }}
      should_deploy: ${{ steps.setup.outputs.should_deploy }}
      image_tag: ${{ steps.setup.outputs.image_tag }}
      ecs_service_name: ${{ steps.setup.outputs.ecs_service_name }}
      task_definition: ${{ steps.setup.outputs.task_definition }}
      
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“‹ Setup Deployment Parameters
        id: setup
        run: |
          # Determine target environment based on trigger
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            SHOULD_DEPLOY="true"
            echo "ğŸ¯ Manual deployment to $ENVIRONMENT"
          elif [ "${{ github.event_name }}" = "push" ]; then
            BRANCH_NAME="${{ github.ref_name }}"
            if [ "$BRANCH_NAME" = "main" ]; then
              ENVIRONMENT="staging"
              echo "ğŸ¯ Main branch push - deploying to STAGING"
            else
              ENVIRONMENT="dev" 
              echo "ğŸ¯ Feature branch push - deploying to DEV"
            fi
            SHOULD_DEPLOY="true"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            ENVIRONMENT="dev"
            SHOULD_DEPLOY="true"
            echo "ğŸ¯ Pull request - deploying to DEV"
          fi

          # Check if streamlit-app files have changed (for non-manual triggers)
          if [ "${{ github.event_name }}" != "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" != "true" ]; then
            if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -q "^streamlit-app/"; then
              echo "ğŸ“ Streamlit app changes detected"
              SHOULD_DEPLOY="true"
            else
              echo "ğŸ“ No streamlit app changes detected"
              if [ "${{ github.event_name }}" != "pull_request" ]; then
                SHOULD_DEPLOY="false"
              fi
            fi
          fi

          # Generate image tag
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:8}"
          IMAGE_TAG="${ENVIRONMENT}-${SHORT_SHA}-$(date +%Y%m%d-%H%M%S)"
          
          # Set environment-specific service names
          case $ENVIRONMENT in
            "dev")
              ECS_SERVICE_NAME="streamlit-app-dev"
              TASK_DEFINITION="streamlit-app-dev"
              ;;
            "staging")
              ECS_SERVICE_NAME="streamlit-app-staging"
              TASK_DEFINITION="streamlit-app-staging"
              ;;
            "prod")
              ECS_SERVICE_NAME="streamlit-app-prod"
              TASK_DEFINITION="streamlit-app-prod"
              ;;
          esac

          # Output all parameters
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "ecs_service_name=$ECS_SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "task_definition=$TASK_DEFINITION" >> $GITHUB_OUTPUT

          # Create deployment summary
          echo "## ğŸ“Š Streamlit App Deployment Plan" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | $ENVIRONMENT |" >> $GITHUB_STEP_SUMMARY
          echo "| Should Deploy | $SHOULD_DEPLOY |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | $IMAGE_TAG |" >> $GITHUB_STEP_SUMMARY
          echo "| ECS Service | $ECS_SERVICE_NAME |" >> $GITHUB_STEP_SUMMARY
          echo "| Task Definition | $TASK_DEFINITION |" >> $GITHUB_STEP_SUMMARY

  # Build and test the Streamlit application
  build:
    name: ğŸ”¨ Build & Test
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_deploy == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: ğŸ“¦ Install UV
        uses: astral-sh/setup-uv@v3

      - name: ğŸ”§ Install Dependencies
        run: |
          cd streamlit-app
          uv venv
          source .venv/bin/activate
          uv pip install -r requirements.txt

      - name: ğŸ§ª Run Tests
        run: |
          cd streamlit-app
          source .venv/bin/activate
          # Add your test commands here
          python -c "import streamlit; import snowflake.connector; print('âœ… Dependencies imported successfully')"
          
      - name: ğŸ” Security Scan
        run: |
          cd streamlit-app
          source .venv/bin/activate
          # Install security scanning tools
          uv pip install bandit safety
          # Run security scans
          bandit -r . -f json -o bandit-report.json || true
          safety check --json --output safety-report.json || true
          echo "ğŸ”’ Security scans completed"

      - name: ğŸ“Š Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: streamlit-app/*-report.json

  # Build and push Docker image
  docker:
    name: ğŸ³ Docker Build & Push
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.should_deploy == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”‘ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ”“ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ—ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ³ Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./streamlit-app
          file: ./streamlit-app/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.setup.outputs.image_tag }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.setup.outputs.environment }}-latest
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: ğŸ” Scan Docker Image for Vulnerabilities
        run: |
          # Install Trivy
          sudo apt-get update && sudo apt-get install -y wget
          wget https://github.com/aquasecurity/trivy/releases/latest/download/trivy_$(dpkg --print-architecture).deb
          sudo dpkg -i trivy_$(dpkg --print-architecture).deb
          
          # Scan the image
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.setup.outputs.image_tag }}"
          trivy image --exit-code 0 --format json --output trivy-report.json $IMAGE_URI
          echo "ğŸ”’ Docker image security scan completed"

      - name: ğŸ“Š Upload Security Scan Results
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results
          path: trivy-report.json

  # Deploy to ECS
  deploy:
    name: ğŸš€ Deploy to ECS
    runs-on: ubuntu-latest
    needs: [setup, docker]
    if: needs.setup.outputs.should_deploy == 'true'
    environment: 
      name: ${{ needs.setup.outputs.environment }}
      
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”‘ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ”“ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ“‹ Download Task Definition Template
        run: |
          # Create task definition from template
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.setup.outputs.image_tag }}"
          
          cat > task-definition.json << EOF
          {
            "family": "${{ needs.setup.outputs.task_definition }}",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "512",
            "memory": "1024",
            "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
            "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskRole",
            "containerDefinitions": [
              {
                "name": "${{ env.CONTAINER_NAME }}",
                "image": "${IMAGE_URI}",
                "essential": true,
                "portMappings": [
                  {
                    "containerPort": 8501,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {
                    "name": "ENVIRONMENT",
                    "value": "${{ needs.setup.outputs.environment }}"
                  },
                  {
                    "name": "AWS_DEFAULT_REGION",
                    "value": "${{ env.AWS_REGION }}"
                  }
                ],
                "secrets": [
                  {
                    "name": "SNOWFLAKE_ACCOUNT",
                    "valueFrom": "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:secret:streamlit/${{ needs.setup.outputs.environment }}/snowflake:ACCOUNT::"
                  },
                  {
                    "name": "SNOWFLAKE_USER", 
                    "valueFrom": "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:secret:streamlit/${{ needs.setup.outputs.environment }}/snowflake:USER::"
                  },
                  {
                    "name": "SNOWFLAKE_PASSWORD",
                    "valueFrom": "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:secret:streamlit/${{ needs.setup.outputs.environment }}/snowflake:PASSWORD::"
                  },
                  {
                    "name": "SNOWFLAKE_DATABASE",
                    "valueFrom": "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:secret:streamlit/${{ needs.setup.outputs.environment }}/snowflake:DATABASE::"
                  },
                  {
                    "name": "SNOWFLAKE_WAREHOUSE",
                    "valueFrom": "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:secret:streamlit/${{ needs.setup.outputs.environment }}/snowflake:WAREHOUSE::"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/streamlit-app/${{ needs.setup.outputs.environment }}",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "curl -f http://localhost:8501/_stcore/health || exit 1"],
                  "interval": 30,
                  "timeout": 10,
                  "retries": 3,
                  "startPeriod": 60
                }
              }
            ]
          }
          EOF

      - name: ğŸš€ Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: task-definition.json
          service: ${{ needs.setup.outputs.ecs_service_name }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: ğŸ” Post-Deployment Verification
        run: |
          echo "ğŸ” Verifying deployment..."
          
          # Wait for service to stabilize
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ needs.setup.outputs.ecs_service_name }}
          
          # Get service details
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ needs.setup.outputs.ecs_service_name }} \
            --query 'services[0]')
          
          RUNNING_COUNT=$(echo $SERVICE_INFO | jq -r '.runningCount')
          DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount')
          
          echo "ğŸƒ Running tasks: $RUNNING_COUNT"
          echo "ğŸ¯ Desired tasks: $DESIRED_COUNT"
          
          if [ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" ]; then
            echo "âœ… Deployment successful!"
          else
            echo "âŒ Deployment verification failed"
            exit 1
          fi

      - name: ğŸ“Š Create Deployment Summary
        run: |
          echo "## ğŸ‰ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.setup.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | ${{ needs.setup.outputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ECS Service | ${{ needs.setup.outputs.ecs_service_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ECS Cluster | ${{ env.ECS_CLUSTER }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Region | ${{ env.AWS_REGION }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Streamlit app deployed successfully!**" >> $GITHUB_STEP_SUMMARY

  # Notification and cleanup
  notify:
    name: ğŸ“¢ Notify & Cleanup
    runs-on: ubuntu-latest
    needs: [setup, build, docker, deploy]
    if: always()
    
    steps:
      - name: ğŸ“¢ Deployment Notification
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "ğŸ‰ Streamlit app deployed successfully to ${{ needs.setup.outputs.environment }}!"
          elif [ "${{ needs.deploy.result }}" = "failure" ]; then
            echo "âŒ Streamlit app deployment to ${{ needs.setup.outputs.environment }} failed!"
          elif [ "${{ needs.deploy.result }}" = "skipped" ]; then
            echo "â­ï¸ Streamlit app deployment was skipped"
          fi