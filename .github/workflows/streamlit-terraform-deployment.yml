name: 🏗️ Streamlit ECS Terraform Deployment

on:
  # Manual trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      action:
        description: 'Terraform Action'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply
          - destroy
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

  # Automatic triggers based on branch and path
  push:
    branches: [main, 'feature/*', 'feat/*']
    paths: 
      - 'streamlit-app/**'
      - 'aws-infrastructure/streamlit-ecs/terraform/**'
      - '.github/workflows/streamlit-terraform-deployment.yml'

  # Pull request trigger for dev deployment
  pull_request:
    branches: [main]
    paths:
      - 'streamlit-app/**'
      - 'aws-infrastructure/streamlit-ecs/terraform/**'
      - '.github/workflows/streamlit-terraform-deployment.yml'

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: snowflake-streamlit-app
  ECS_CLUSTER: snowflake-analytics-cluster
  CONTAINER_NAME: streamlit-app
  TF_VERSION: "1.5.7"
  
jobs:
  # Determine deployment environment and parameters
  setup:
    name: 🏗️ Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.setup.outputs.environment }}
      should_deploy: ${{ steps.setup.outputs.should_deploy }}
      terraform_action: ${{ steps.setup.outputs.terraform_action }}
      image_tag: ${{ steps.setup.outputs.image_tag }}
      working_directory: ${{ steps.setup.outputs.working_directory }}
      
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 📋 Setup Deployment Parameters
        id: setup
        run: |
          # Determine target environment and action based on trigger
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            TERRAFORM_ACTION="${{ github.event.inputs.action }}"
            SHOULD_DEPLOY="true"
            echo "🎯 Manual deployment: $TERRAFORM_ACTION to $ENVIRONMENT"
          elif [ "${{ github.event_name }}" = "push" ]; then
            BRANCH_NAME="${{ github.ref_name }}"
            TERRAFORM_ACTION="apply"
            if [ "$BRANCH_NAME" = "main" ]; then
              ENVIRONMENT="staging"
              echo "🎯 Main branch push - deploying to STAGING"
            else
              ENVIRONMENT="dev" 
              echo "🎯 Feature branch push - deploying to DEV"
            fi
            SHOULD_DEPLOY="true"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            ENVIRONMENT="dev"
            TERRAFORM_ACTION="plan"
            SHOULD_DEPLOY="true"
            echo "🎯 Pull request - planning DEV deployment"
          fi

          # Check if relevant files have changed (for non-manual triggers)
          if [ "${{ github.event_name }}" != "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" != "true" ]; then
            if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -E "^(streamlit-app/|aws-infrastructure/streamlit-ecs/terraform/)"; then
              echo "📁 Relevant changes detected"
              SHOULD_DEPLOY="true"
            else
              echo "📁 No relevant changes detected"
              if [ "${{ github.event_name }}" != "pull_request" ]; then
                SHOULD_DEPLOY="false"
              fi
            fi
          fi

          # Generate image tag
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:8}"
          IMAGE_TAG="${ENVIRONMENT}-${SHORT_SHA}-$(date +%Y%m%d-%H%M%S)"
          
          # Set working directory
          WORKING_DIRECTORY="aws-infrastructure/streamlit-ecs/terraform"

          # Output all parameters
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "terraform_action=$TERRAFORM_ACTION" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "working_directory=$WORKING_DIRECTORY" >> $GITHUB_OUTPUT

          # Create deployment summary
          echo "## 🏗️ Terraform Deployment Plan" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | $ENVIRONMENT |" >> $GITHUB_STEP_SUMMARY
          echo "| Action | $TERRAFORM_ACTION |" >> $GITHUB_STEP_SUMMARY
          echo "| Should Deploy | $SHOULD_DEPLOY |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | $IMAGE_TAG |" >> $GITHUB_STEP_SUMMARY
          echo "| Working Directory | $WORKING_DIRECTORY |" >> $GITHUB_STEP_SUMMARY

  # Build and test the Streamlit application
  build:
    name: 🔨 Build & Test
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_deploy == 'true'
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🐍 Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 📦 Install UV
        uses: astral-sh/setup-uv@v3

      - name: 🔧 Install Dependencies
        run: |
          cd streamlit-app
          uv venv
          source .venv/bin/activate
          uv pip install -r requirements.txt

      - name: 🧪 Run Tests
        run: |
          cd streamlit-app
          source .venv/bin/activate
          # Add your test commands here
          python -c "import streamlit; import snowflake.connector; print('✅ Dependencies imported successfully')"
          
      - name: 🔍 Security Scan
        run: |
          cd streamlit-app
          source .venv/bin/activate
          # Install security scanning tools
          uv pip install bandit safety
          # Run security scans
          bandit -r . -f json -o bandit-report.json || true
          safety check --json --output safety-report.json || true
          echo "🔒 Security scans completed"

      - name: 📊 Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ needs.setup.outputs.environment }}
          path: streamlit-app/*-report.json

  # Terraform Infrastructure Management
  terraform:
    name: 🏗️ Terraform ${{ needs.setup.outputs.terraform_action }}
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.should_deploy == 'true'
    environment: 
      name: ${{ needs.setup.outputs.environment }}
    defaults:
      run:
        working-directory: ${{ needs.setup.outputs.working_directory }}
      
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🔑 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: 🏗️ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: 🔧 Terraform Init
        run: |
          terraform init -backend-config=environments/${{ needs.setup.outputs.environment }}.backend

      - name: 🔍 Terraform Validate
        run: terraform validate

      - name: 📋 Terraform Plan
        id: plan
        run: |
          terraform plan \
            -var-file=environments/${{ needs.setup.outputs.environment }}.tfvars \
            -out=tfplan \
            -detailed-exitcode
        continue-on-error: true

      - name: 📊 Update PR with Terraform Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Get terraform plan output
            let planOutput;
            try {
              planOutput = execSync('cd ${{ needs.setup.outputs.working_directory }} && terraform show -no-color tfplan', { encoding: 'utf8' });
            } catch (error) {
              planOutput = 'Error generating plan output';
            }
            
            const output = `
            ## 🏗️ Terraform Plan (${{ needs.setup.outputs.environment }})
            
            **Action:** \`${{ needs.setup.outputs.terraform_action }}\`
            **Environment:** \`${{ needs.setup.outputs.environment }}\`
            **Plan Exit Code:** \`${{ steps.plan.outputs.exitcode }}\`
            
            <details>
            <summary>Show Plan</summary>
            
            \`\`\`terraform
            ${planOutput}
            \`\`\`
            
            </details>
            
            *Plan generated by GitHub Actions*
            `;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('🏗️ Terraform Plan')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: output
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: output
              });
            }

      - name: ❌ Terraform Plan Failed
        if: steps.plan.outcome == 'failure'
        run: |
          echo "❌ Terraform plan failed"
          exit 1

      - name: 🚀 Terraform Apply
        if: needs.setup.outputs.terraform_action == 'apply' && steps.plan.outputs.exitcode == '2'
        run: |
          terraform apply -auto-approve tfplan

      - name: 💥 Terraform Destroy
        if: needs.setup.outputs.terraform_action == 'destroy'
        run: |
          terraform plan -destroy \
            -var-file=environments/${{ needs.setup.outputs.environment }}.tfvars \
            -out=destroy-plan
          terraform apply -auto-approve destroy-plan

      - name: 📊 Terraform Outputs
        if: needs.setup.outputs.terraform_action == 'apply' && steps.plan.outputs.exitcode == '2'
        id: outputs
        run: |
          echo "## 🎯 Terraform Outputs" >> $GITHUB_STEP_SUMMARY
          terraform output -json > terraform-outputs.json
          cat terraform-outputs.json | jq -r '
            "| Output | Value |",
            "|--------|-------|",
            (to_entries[] | "| \(.key) | \(.value.value) |")
          ' >> $GITHUB_STEP_SUMMARY
          
          # Export key outputs for next jobs
          echo "ecr_repository_uri=$(terraform output -raw ecr_repository_uri)" >> $GITHUB_OUTPUT
          echo "ecs_cluster_name=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_OUTPUT
          echo "ecs_service_name=$(terraform output -raw ecs_service_name)" >> $GITHUB_OUTPUT
          echo "streamlit_app_url=$(terraform output -raw streamlit_app_url)" >> $GITHUB_OUTPUT

      - name: 📊 Upload Terraform Plan
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: terraform-plan-${{ needs.setup.outputs.environment }}
          path: |
            ${{ needs.setup.outputs.working_directory }}/tfplan
            ${{ needs.setup.outputs.working_directory }}/terraform-outputs.json
          retention-days: 30

  # Build and push Docker image (only if infrastructure was successfully applied)
  docker:
    name: 🐳 Docker Build & Push
    runs-on: ubuntu-latest
    needs: [setup, terraform]
    if: needs.setup.outputs.should_deploy == 'true' && needs.setup.outputs.terraform_action == 'apply' && needs.terraform.result == 'success'
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🔑 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: 🔓 Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: 🏗️ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🐳 Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./streamlit-app
          file: ./streamlit-app/Dockerfile
          push: true
          tags: |
            ${{ needs.terraform.outputs.ecr_repository_uri }}:${{ needs.setup.outputs.image_tag }}
            ${{ needs.terraform.outputs.ecr_repository_uri }}:${{ needs.setup.outputs.environment }}-latest
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: 🔍 Scan Docker Image for Vulnerabilities
        run: |
          # Install Trivy
          sudo apt-get update && sudo apt-get install -y wget
          wget https://github.com/aquasecurity/trivy/releases/latest/download/trivy_$(dpkg --print-architecture).deb
          sudo dpkg -i trivy_$(dpkg --print-architecture).deb
          
          # Scan the image
          IMAGE_URI="${{ needs.terraform.outputs.ecr_repository_uri }}:${{ needs.setup.outputs.image_tag }}"
          trivy image --exit-code 0 --format json --output trivy-report.json $IMAGE_URI
          echo "🔒 Docker image security scan completed"

      - name: 📊 Upload Security Scan Results
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results-${{ needs.setup.outputs.environment }}
          path: trivy-report.json

  # Deploy to ECS (update service with new image)
  deploy:
    name: 🚀 Deploy to ECS
    runs-on: ubuntu-latest
    needs: [setup, terraform, docker]
    if: needs.setup.outputs.should_deploy == 'true' && needs.setup.outputs.terraform_action == 'apply' && needs.terraform.result == 'success'
    environment: 
      name: ${{ needs.setup.outputs.environment }}
      
    steps:
      - name: 🔑 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: 🔄 Update ECS Service
        run: |
          echo "🚀 Updating ECS service with new image..."
          aws ecs update-service \
            --cluster ${{ needs.terraform.outputs.ecs_cluster_name }} \
            --service ${{ needs.terraform.outputs.ecs_service_name }} \
            --force-new-deployment
          
          echo "⏳ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ needs.terraform.outputs.ecs_cluster_name }} \
            --services ${{ needs.terraform.outputs.ecs_service_name }}

      - name: 🔍 Post-Deployment Verification
        run: |
          echo "🔍 Verifying deployment..."
          
          # Get service details
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster ${{ needs.terraform.outputs.ecs_cluster_name }} \
            --services ${{ needs.terraform.outputs.ecs_service_name }} \
            --query 'services[0]')
          
          RUNNING_COUNT=$(echo $SERVICE_INFO | jq -r '.runningCount')
          DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount')
          
          echo "🏃 Running tasks: $RUNNING_COUNT"
          echo "🎯 Desired tasks: $DESIRED_COUNT"
          
          if [ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" ]; then
            echo "✅ Deployment successful!"
          else
            echo "❌ Deployment verification failed"
            exit 1
          fi

      - name: 🌐 Test Application Health
        run: |
          echo "🌐 Testing application health..."
          APP_URL="${{ needs.terraform.outputs.streamlit_app_url }}"
          
          # Wait a bit for the app to start
          sleep 30
          
          # Test health endpoint
          if curl -f --max-time 30 "${APP_URL}/_stcore/health"; then
            echo "✅ Application health check passed"
          else
            echo "⚠️ Application health check failed (may still be starting)"
          fi

      - name: 📊 Create Deployment Summary
        run: |
          echo "## 🎉 Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.setup.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | ${{ needs.setup.outputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ECS Service | ${{ needs.terraform.outputs.ecs_service_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ECS Cluster | ${{ needs.terraform.outputs.ecs_cluster_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Application URL | ${{ needs.terraform.outputs.streamlit_app_url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Region | ${{ env.AWS_REGION }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Streamlit app deployed successfully using Terraform!**" >> $GITHUB_STEP_SUMMARY

  # Notification and cleanup
  notify:
    name: 📢 Notify & Cleanup
    runs-on: ubuntu-latest
    needs: [setup, terraform, docker, deploy]
    if: always()
    
    steps:
      - name: 📢 Deployment Notification
        run: |
          ACTION="${{ needs.setup.outputs.terraform_action }}"
          ENVIRONMENT="${{ needs.setup.outputs.environment }}"
          
          if [ "$ACTION" = "destroy" ]; then
            if [ "${{ needs.terraform.result }}" = "success" ]; then
              echo "🗑️ Infrastructure destroyed successfully in $ENVIRONMENT!"
            else
              echo "❌ Infrastructure destruction failed in $ENVIRONMENT!"
            fi
          elif [ "$ACTION" = "plan" ]; then
            if [ "${{ needs.terraform.result }}" = "success" ]; then
              echo "📋 Terraform plan completed for $ENVIRONMENT!"
            else
              echo "❌ Terraform plan failed for $ENVIRONMENT!"
            fi
          elif [ "$ACTION" = "apply" ]; then
            if [ "${{ needs.deploy.result }}" = "success" ]; then
              echo "🎉 Streamlit app deployed successfully to $ENVIRONMENT using Terraform!"
            elif [ "${{ needs.terraform.result }}" = "success" ]; then
              echo "🏗️ Infrastructure deployed successfully, but application deployment was skipped"
            elif [ "${{ needs.terraform.result }}" = "failure" ]; then
              echo "❌ Infrastructure deployment failed in $ENVIRONMENT!"
            elif [ "${{ needs.deploy.result }}" = "failure" ]; then
              echo "❌ Application deployment failed in $ENVIRONMENT!"
            elif [ "${{ needs.deploy.result }}" = "skipped" ]; then
              echo "⏭️ Deployment was skipped"
            fi
          fi