name: ğŸ—ï¸ Streamlit ECS Terraform Deployment

on:
  # Manual trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      action:
        description: 'Terraform Action'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply
          - destroy
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

  # Automatic triggers based on branch and path
  push:
    branches: [main, 'feature/*', 'feat/*']
    paths: 
      - 'streamlit-app/**'
      - 'aws-infrastructure/streamlit-ecs/terraform/**'
      - '.github/workflows/streamlit-terraform-deployment.yml'

  # Pull request trigger for dev deployment
  pull_request:
    branches: [main]
    paths:
      - 'streamlit-app/**'
      - 'aws-infrastructure/streamlit-ecs/terraform/**'
      - '.github/workflows/streamlit-terraform-deployment.yml'

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: snowflake-streamlit-app
  ECS_CLUSTER: snowflake-analytics-cluster
  CONTAINER_NAME: streamlit-app
  TF_VERSION: "1.5.7"
  
jobs:
  # Determine deployment environment and parameters
  setup:
    name: ğŸ—ï¸ Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.setup.outputs.environment }}
      should_deploy: ${{ steps.setup.outputs.should_deploy }}
      terraform_action: ${{ steps.setup.outputs.terraform_action }}
      image_tag: ${{ steps.setup.outputs.image_tag }}
      working_directory: ${{ steps.setup.outputs.working_directory }}
      
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“‹ Setup Deployment Parameters
        id: setup
        run: |
          # Determine target environment and action based on trigger
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            TERRAFORM_ACTION="${{ github.event.inputs.action }}"
            SHOULD_DEPLOY="true"
            echo "ğŸ¯ Manual deployment: $TERRAFORM_ACTION to $ENVIRONMENT"
          elif [ "${{ github.event_name }}" = "push" ]; then
            BRANCH_NAME="${{ github.ref_name }}"
            TERRAFORM_ACTION="apply"
            if [ "$BRANCH_NAME" = "main" ]; then
              ENVIRONMENT="staging"
              echo "ğŸ¯ Main branch push - deploying to STAGING"
            else
              ENVIRONMENT="dev" 
              echo "ğŸ¯ Feature branch push - deploying to DEV"
            fi
            SHOULD_DEPLOY="true"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            ENVIRONMENT="dev"
            TERRAFORM_ACTION="plan"
            SHOULD_DEPLOY="true"
            echo "ğŸ¯ Pull request - planning DEV deployment"
          fi

          # Check if relevant files have changed (for non-manual triggers)
          if [ "${{ github.event_name }}" != "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" != "true" ]; then
            if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -E "^(streamlit-app/|aws-infrastructure/streamlit-ecs/terraform/)"; then
              echo "ğŸ“ Relevant changes detected"
              SHOULD_DEPLOY="true"
            else
              echo "ğŸ“ No relevant changes detected"
              if [ "${{ github.event_name }}" != "pull_request" ]; then
                SHOULD_DEPLOY="false"
              fi
            fi
          fi

          # Generate image tag
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:8}"
          IMAGE_TAG="${ENVIRONMENT}-${SHORT_SHA}-$(date +%Y%m%d-%H%M%S)"
          
          # Set working directory
          WORKING_DIRECTORY="aws-infrastructure/streamlit-ecs/terraform"

          # Output all parameters
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "terraform_action=$TERRAFORM_ACTION" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "working_directory=$WORKING_DIRECTORY" >> $GITHUB_OUTPUT

          # Create deployment summary
          echo "## ğŸ—ï¸ Terraform Deployment Plan" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | $ENVIRONMENT |" >> $GITHUB_STEP_SUMMARY
          echo "| Action | $TERRAFORM_ACTION |" >> $GITHUB_STEP_SUMMARY
          echo "| Should Deploy | $SHOULD_DEPLOY |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | $IMAGE_TAG |" >> $GITHUB_STEP_SUMMARY
          echo "| Working Directory | $WORKING_DIRECTORY |" >> $GITHUB_STEP_SUMMARY

  # Build and test the Streamlit application
  build:
    name: ğŸ”¨ Build & Test
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_deploy == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: ğŸ“¦ Install UV
        uses: astral-sh/setup-uv@v3

      - name: ğŸ”§ Install Dependencies
        run: |
          cd streamlit-app
          uv venv
          source .venv/bin/activate
          uv pip install -r requirements.txt

      - name: ğŸ§ª Run Tests
        run: |
          cd streamlit-app
          source .venv/bin/activate
          # Add your test commands here
          python -c "import streamlit; import snowflake.connector; print('âœ… Dependencies imported successfully')"
          
      - name: ğŸ” Security Scan
        run: |
          cd streamlit-app
          source .venv/bin/activate
          # Install security scanning tools
          uv pip install bandit safety
          # Run security scans
          bandit -r . -f json -o bandit-report.json || true
          safety check --json --output safety-report.json || true
          echo "ğŸ”’ Security scans completed"

      - name: ğŸ“Š Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ needs.setup.outputs.environment }}
          path: streamlit-app/*-report.json

  # Terraform Infrastructure Management
  terraform:
    name: ğŸ—ï¸ Terraform ${{ needs.setup.outputs.terraform_action }}
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.should_deploy == 'true'
    environment: 
      name: ${{ needs.setup.outputs.environment }}
    defaults:
      run:
        working-directory: ${{ needs.setup.outputs.working_directory }}
      
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”‘ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ğŸ”§ Terraform Init
        run: |
          terraform init -backend-config=environments/${{ needs.setup.outputs.environment }}.backend

      - name: ğŸ” Terraform Validate
        run: terraform validate

      - name: ğŸ“‹ Terraform Plan
        id: plan
        run: |
          terraform plan \
            -var-file=environments/${{ needs.setup.outputs.environment }}.tfvars \
            -out=tfplan \
            -detailed-exitcode
        continue-on-error: true

      - name: ğŸ“Š Update PR with Terraform Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Get terraform plan output
            let planOutput;
            try {
              planOutput = execSync('cd ${{ needs.setup.outputs.working_directory }} && terraform show -no-color tfplan', { encoding: 'utf8' });
            } catch (error) {
              planOutput = 'Error generating plan output';
            }
            
            const output = `
            ## ğŸ—ï¸ Terraform Plan (${{ needs.setup.outputs.environment }})
            
            **Action:** \`${{ needs.setup.outputs.terraform_action }}\`
            **Environment:** \`${{ needs.setup.outputs.environment }}\`
            **Plan Exit Code:** \`${{ steps.plan.outputs.exitcode }}\`
            
            <details>
            <summary>Show Plan</summary>
            
            \`\`\`terraform
            ${planOutput}
            \`\`\`
            
            </details>
            
            *Plan generated by GitHub Actions*
            `;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ğŸ—ï¸ Terraform Plan')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: output
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: output
              });
            }

      - name: âŒ Terraform Plan Failed
        if: steps.plan.outcome == 'failure'
        run: |
          echo "âŒ Terraform plan failed"
          exit 1

      - name: ğŸš€ Terraform Apply
        if: needs.setup.outputs.terraform_action == 'apply' && steps.plan.outputs.exitcode == '2'
        run: |
          terraform apply -auto-approve tfplan

      - name: ğŸ’¥ Terraform Destroy
        if: needs.setup.outputs.terraform_action == 'destroy'
        run: |
          terraform plan -destroy \
            -var-file=environments/${{ needs.setup.outputs.environment }}.tfvars \
            -out=destroy-plan
          terraform apply -auto-approve destroy-plan

      - name: ğŸ“Š Terraform Outputs
        if: needs.setup.outputs.terraform_action == 'apply' && steps.plan.outputs.exitcode == '2'
        id: outputs
        run: |
          echo "## ğŸ¯ Terraform Outputs" >> $GITHUB_STEP_SUMMARY
          terraform output -json > terraform-outputs.json
          cat terraform-outputs.json | jq -r '
            "| Output | Value |",
            "|--------|-------|",
            (to_entries[] | "| \(.key) | \(.value.value) |")
          ' >> $GITHUB_STEP_SUMMARY
          
          # Export key outputs for next jobs
          echo "ecr_repository_uri=$(terraform output -raw ecr_repository_uri)" >> $GITHUB_OUTPUT
          echo "ecs_cluster_name=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_OUTPUT
          echo "ecs_service_name=$(terraform output -raw ecs_service_name)" >> $GITHUB_OUTPUT
          echo "streamlit_app_url=$(terraform output -raw streamlit_app_url)" >> $GITHUB_OUTPUT

      - name: ğŸ“Š Upload Terraform Plan
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: terraform-plan-${{ needs.setup.outputs.environment }}
          path: |
            ${{ needs.setup.outputs.working_directory }}/tfplan
            ${{ needs.setup.outputs.working_directory }}/terraform-outputs.json
          retention-days: 30

  # Build and push Docker image (only if infrastructure was successfully applied)
  docker:
    name: ğŸ³ Docker Build & Push
    runs-on: ubuntu-latest
    needs: [setup, terraform]
    if: needs.setup.outputs.should_deploy == 'true' && needs.setup.outputs.terraform_action == 'apply' && needs.terraform.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”‘ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ”“ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ—ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ³ Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./streamlit-app
          file: ./streamlit-app/Dockerfile
          push: true
          tags: |
            ${{ needs.terraform.outputs.ecr_repository_uri }}:${{ needs.setup.outputs.image_tag }}
            ${{ needs.terraform.outputs.ecr_repository_uri }}:${{ needs.setup.outputs.environment }}-latest
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: ğŸ” Scan Docker Image for Vulnerabilities
        run: |
          # Install Trivy
          sudo apt-get update && sudo apt-get install -y wget
          wget https://github.com/aquasecurity/trivy/releases/latest/download/trivy_$(dpkg --print-architecture).deb
          sudo dpkg -i trivy_$(dpkg --print-architecture).deb
          
          # Scan the image
          IMAGE_URI="${{ needs.terraform.outputs.ecr_repository_uri }}:${{ needs.setup.outputs.image_tag }}"
          trivy image --exit-code 0 --format json --output trivy-report.json $IMAGE_URI
          echo "ğŸ”’ Docker image security scan completed"

      - name: ğŸ“Š Upload Security Scan Results
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results-${{ needs.setup.outputs.environment }}
          path: trivy-report.json

  # Deploy to ECS (update service with new image)
  deploy:
    name: ğŸš€ Deploy to ECS
    runs-on: ubuntu-latest
    needs: [setup, terraform, docker]
    if: needs.setup.outputs.should_deploy == 'true' && needs.setup.outputs.terraform_action == 'apply' && needs.terraform.result == 'success'
    environment: 
      name: ${{ needs.setup.outputs.environment }}
      
    steps:
      - name: ğŸ”‘ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ”„ Update ECS Service
        run: |
          echo "ğŸš€ Updating ECS service with new image..."
          aws ecs update-service \
            --cluster ${{ needs.terraform.outputs.ecs_cluster_name }} \
            --service ${{ needs.terraform.outputs.ecs_service_name }} \
            --force-new-deployment
          
          echo "â³ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ needs.terraform.outputs.ecs_cluster_name }} \
            --services ${{ needs.terraform.outputs.ecs_service_name }}

      - name: ğŸ” Post-Deployment Verification
        run: |
          echo "ğŸ” Verifying deployment..."
          
          # Get service details
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster ${{ needs.terraform.outputs.ecs_cluster_name }} \
            --services ${{ needs.terraform.outputs.ecs_service_name }} \
            --query 'services[0]')
          
          RUNNING_COUNT=$(echo $SERVICE_INFO | jq -r '.runningCount')
          DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount')
          
          echo "ğŸƒ Running tasks: $RUNNING_COUNT"
          echo "ğŸ¯ Desired tasks: $DESIRED_COUNT"
          
          if [ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" ]; then
            echo "âœ… Deployment successful!"
          else
            echo "âŒ Deployment verification failed"
            exit 1
          fi

      - name: ğŸŒ Test Application Health
        run: |
          echo "ğŸŒ Testing application health..."
          APP_URL="${{ needs.terraform.outputs.streamlit_app_url }}"
          
          # Wait a bit for the app to start
          sleep 30
          
          # Test health endpoint
          if curl -f --max-time 30 "${APP_URL}/_stcore/health"; then
            echo "âœ… Application health check passed"
          else
            echo "âš ï¸ Application health check failed (may still be starting)"
          fi

      - name: ğŸ“Š Create Deployment Summary
        run: |
          echo "## ğŸ‰ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.setup.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | ${{ needs.setup.outputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ECS Service | ${{ needs.terraform.outputs.ecs_service_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ECS Cluster | ${{ needs.terraform.outputs.ecs_cluster_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Application URL | ${{ needs.terraform.outputs.streamlit_app_url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Region | ${{ env.AWS_REGION }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Streamlit app deployed successfully using Terraform!**" >> $GITHUB_STEP_SUMMARY

  # Notification and cleanup
  notify:
    name: ğŸ“¢ Notify & Cleanup
    runs-on: ubuntu-latest
    needs: [setup, terraform, docker, deploy]
    if: always()
    
    steps:
      - name: ğŸ“¢ Deployment Notification
        run: |
          ACTION="${{ needs.setup.outputs.terraform_action }}"
          ENVIRONMENT="${{ needs.setup.outputs.environment }}"
          
          if [ "$ACTION" = "destroy" ]; then
            if [ "${{ needs.terraform.result }}" = "success" ]; then
              echo "ğŸ—‘ï¸ Infrastructure destroyed successfully in $ENVIRONMENT!"
            else
              echo "âŒ Infrastructure destruction failed in $ENVIRONMENT!"
            fi
          elif [ "$ACTION" = "plan" ]; then
            if [ "${{ needs.terraform.result }}" = "success" ]; then
              echo "ğŸ“‹ Terraform plan completed for $ENVIRONMENT!"
            else
              echo "âŒ Terraform plan failed for $ENVIRONMENT!"
            fi
          elif [ "$ACTION" = "apply" ]; then
            if [ "${{ needs.deploy.result }}" = "success" ]; then
              echo "ğŸ‰ Streamlit app deployed successfully to $ENVIRONMENT using Terraform!"
            elif [ "${{ needs.terraform.result }}" = "success" ]; then
              echo "ğŸ—ï¸ Infrastructure deployed successfully, but application deployment was skipped"
            elif [ "${{ needs.terraform.result }}" = "failure" ]; then
              echo "âŒ Infrastructure deployment failed in $ENVIRONMENT!"
            elif [ "${{ needs.deploy.result }}" = "failure" ]; then
              echo "âŒ Application deployment failed in $ENVIRONMENT!"
            elif [ "${{ needs.deploy.result }}" = "skipped" ]; then
              echo "â­ï¸ Deployment was skipped"
            fi
          fi